/**
 * This Firestore Security Ruleset is designed for the Danny Store e-commerce platform.
 *
 * Core Philosophy:
 * The security model enforces a strict user-ownership paradigm for all sensitive and personal
 * data, such as user profiles, orders, and virtual try-on history. Publicly accessible
 * data, like the product catalog and reviews, is readable by anyone, but write operations
 * are tightly controlled to maintain data integrity.
 *
 * Data Structure:
 * The data is organized into two main categories:
 * 1. User-Private Data: All data specific to a user (profiles, orders, etc.) is nested
 *    hierarchically under the `/users/{userId}` path. This structure enables simple,
 *    performant, path-based security rules.
 * 2. Public Data: The general product catalog and associated reviews are stored in a
 *    top-level `/products` collection, allowing for efficient public queries.
 *
 * Key Security Decisions:
 * - User Isolation: A user can only access data within their own `/users/{userId}` document tree.
 *   They cannot read, write, or even list data belonging to any other user.
 * - Public Read, Owner Write: Collections like product reviews are publicly readable,
 *   but only the original author of a review is permitted to update or delete it. This is
 *   enforced by checking a `userId` field denormalized onto the review document itself.
 * - Admin-Only Writes (Locked): Writes to the global product catalog are disabled for all
 *   client-side users. These operations should be performed via a trusted server environment
 *   using the Admin SDK.
 * - Disallowed User Listing: The top-level `/users` collection cannot be listed to protect
 *   user privacy and prevent data scraping.
 * - Insecure Path Lockdown: The `/orders/{orderId}/items` path is locked down completely.
 *   As a top-level collection, it lacks user context in its path, making it impossible to
 *   securely determine ownership without violating the design principle of avoiding `get()` calls.
 *   This collection should be redesigned as a subcollection: `/users/{userId}/orders/{orderId}/items/{itemId}`.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    //-------------------------------------------------------------------------//
    // Helper Functions
    //-------------------------------------------------------------------------//

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently signed-in user's UID matches the given userId.
     * This is the primary function for enforcing data ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks for ownership on an existing document. Used for update and delete
     * operations to prevent acting on non-existent data.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates that the `id` field within a new user document matches the
     * document ID, ensuring relational integrity at creation.
     */
    function isCreatingOwnUserDoc(userId) {
      return isOwner(userId) && request.resource.data.id == userId;
    }

    /**
     * Enforces immutability of the `id` field on a user document during an update.
     */
    function isUpdatingOwnUserDoc(userId) {
      return isOwner(userId) && request.resource.data.id == resource.data.id;
    }

    /**
     * Validates that the `userId` field within a new user-owned document
     * (e.g., Order, Session) matches the user's ID in the path.
     */
    function isCreatingOwnDoc(userId) {
        return isOwner(userId) && request.resource.data.userId == userId;
    }

    /**
     * Enforces immutability of the `userId` field on a user-owned document
     * (e.g., Order, Session) during an update.
     */
    function isUpdatingOwnDoc(userId) {
        return isOwner(userId) && request.resource.data.userId == resource.data.userId;
    }

    /**
     * Validates that a user is creating a review and correctly self-assigning
     * their own userId to the document.
     */
    function isCreatingOwnContent() {
      return isSignedIn() && request.resource.data.userId == request.auth.uid;
    }

    /**
     * Validates that a user is updating or deleting content they own, based on
     * the userId field in the existing document.
     */
    function isUpdatingOwnContent() {
      return isSignedIn() && resource != null && resource.data.userId == request.auth.uid;
    }


    //-------------------------------------------------------------------------//
    // Collection Rules
    //-------------------------------------------------------------------------//

    /**
     * @description Manages user profile documents. A user can create and manage their own profile.
     * @path /users/{userId}
     * @allow (create) A new user signing up, creating a document where {userId} is their own UID.
     * @deny (get) User 'A' attempting to read the profile of User 'B'.
     * @deny (list) Any user attempting to list all documents in the `/users` collection.
     * @principle Enforces self-creation and strict data ownership to protect user privacy.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isCreatingOwnUserDoc(userId);
      allow update: if isUpdatingOwnUserDoc(userId);
      allow delete: if isExistingOwner(userId);

      /**
       * @description Manages a user's private order history.
       * @path /users/{userId}/orders/{orderId}
       * @allow (get, list) A user reading their own list of orders.
       * @deny (get) User 'A' attempting to read an order belonging to User 'B'.
       * @principle Restricts access to a user's own data tree, ensuring order privacy.
       */
      match /orders/{orderId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isCreatingOwnDoc(userId);
        allow update: if isUpdatingOwnDoc(userId);
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Manages a user's private virtual try-on sessions.
       * @path /users/{userId}/tryon_sessions/{sessionId}
       * @allow (create) A user creating a new session record for themselves.
       * @deny (list) User 'A' attempting to list all sessions for User 'B'.
       * @principle Restricts access to a user's own data tree.
       */
      match /tryon_sessions/{sessionId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isCreatingOwnDoc(userId);
        allow update: if isUpdatingOwnDoc(userId);
        allow delete: if isExistingOwner(userId);
      }
    }

    /**
     * @description The public product catalog. All data here is readable by any client.
     * @path /products/{productId}
     * @allow (get, list) Any user, signed-in or anonymous, viewing products.
     * @deny (create, update, delete) Any client attempting to modify the product catalog.
     * @principle Defines a public read-only collection. Writes must be done via a trusted admin environment.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;

      /**
       * @description Product variants. Inherits the public read-only policy of its parent product.
       * @path /products/{productId}/variants/{variantId}
       * @allow (get) Any user viewing a specific size or color variant of a product.
       * @deny (create) Any client attempting to add a new variant.
       * @principle Public read-only data, consistent with the parent collection.
       */
      match /variants/{variantId} {
        allow get: if true;
        allow list: if true;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
      }

      /**
       * @description Publicly readable product reviews. Users can create reviews and manage their own.
       * @path /products/{productId}/reviews/{reviewId}
       * @allow (create) An authenticated user creating a new review for a product.
       * @deny (update) User 'A' attempting to modify a review written by User 'B'.
       * @principle Public read with owner-only writes, based on a denormalized `userId` field.
       */
      match /reviews/{reviewId} {
        allow get: if true;
        allow list: if true;
        allow create: if isCreatingOwnContent();
        allow update: if isUpdatingOwnContent();
        allow delete: if isUpdatingOwnContent();
      }
    }

    /**
     * @description **INSECURE DATA MODEL - COLLECTION LOCKED DOWN**
     * @path /orders/{orderId}/items/{itemId}
     * @allow No operations are allowed.
     * @deny All operations are denied for all users.
     * @principle This path is insecure because it lacks user context (`userId`). It cannot be
     *            safely secured without significant data model changes. To be secure, this
     *            should be a subcollection of a user's order, for example:
     *            `/users/{userId}/orders/{orderId}/items/{itemId}`.
     */
    match /orders/{orderId}/items/{itemId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}