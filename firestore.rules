/**
 * # Core Philosophy
 * This ruleset enforces a strict role-based access control (RBAC) model, clearly
 * separating public users from administrators. The entire content management system
 * (CMS) is writable only by users designated as administrators. Public content, such
 * as published articles and pages, is read-only for everyone, including anonymous
 * visitors. This ensures a secure, centralized content management workflow.
 *
 * # Data Structure
 * The data is organized into top-level collections, each corresponding to a major
 * CMS entity (e.g., /articles, /pages, /media). Administrator privileges are
 * managed by the existence of a document in the `/roles_admin/{userId}` collection.
 * This structure decouples content from user-specific data, simplifying security logic.
 *
 * # Key Security Decisions
 * - Admin-Only Writes: All write operations (`create`, `update`, `delete`) on any
 *   CMS collection are exclusively granted to authenticated administrators.
 * - Public Read Access: Most CMS content is publicly readable to support the website's
 *   frontend. For content with a publication status (like articles and pages), read
 *   access is conditionally granted based on a 'published' status to prevent drafts
 *   from being exposed.
 * - Role Management Lockdown: The `/roles_admin` collection is the source of truth for
 *   admin roles. To prevent privilege escalation, it is made read-only within these
 *   rules. Administrators must be managed securely through the Firebase Console or a
 *   trusted server-side process (Admin SDK).
 * - No User Listing: The rules do not permit listing of administrative or sensitive
 *   collections by non-privileged users.
 *
 * # Denormalization for Authorization
 * The primary authorization mechanism is the `/roles_admin` collection. The existence
 * of a document at `/roles_admin/$(request.auth.uid)` grants a user admin privileges.
 * This allows for a fast and cost-effective `exists()` check in the rules, avoiding
 * the need to read a user's profile document for every single operation.
 *
 * # Structural Segregation
 * This ruleset uses a 'status' field (e.g., `status == 'published'`) within a single
 * collection to differentiate public from private content. While separate collections
 * for drafts and published content can be more secure for list operations, this
 * approach is chosen to simplify the admin experience, allowing administrators to
 * query and manage all content from a single location. Public `list` operations are
 * permitted, but client applications are responsible for filtering queries to show
 * only published content.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the user is an administrator by verifying the existence of a
     * corresponding document in the roles_admin collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Checks if a document is marked as 'published'. This is used to control
     * public visibility of content like articles and pages.
     */
    function isPublished() {
      return resource.data.status == 'published';
    }

    // -------------------------------------------------------------------------
    // Collection Rules
    // -------------------------------------------------------------------------

    /**
     * @description Manages CMS articles. Published articles are public-read.
     *   Only administrators can create, update, or delete any article.
     * @path /articles/{articleId}
     * @allow (get) Any user reading a published article.
     * @deny (create) A non-admin user trying to create an article.
     * @principle Public read for published content, with admin-only writes.
     */
    match /articles/{articleId} {
      allow get: if isPublished() || isAdmin();
      allow list: if true; // CRITICAL: Client must filter queries by `where('status', '==', 'published')`
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Manages static CMS pages. Published pages are public-read.
     *   Only administrators can create, update, or delete any page.
     * @path /pages/{pageId}
     * @allow (get) Any user reading a published page.
     * @deny (update) An admin trying to update a non-existent page.
     * @principle Public read for published content, with admin-only writes.
     */
    match /pages/{pageId} {
      allow get: if isPublished() || isAdmin();
      allow list: if true; // CRITICAL: Client must filter queries by `where('status', '==', 'published')`
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Manages article categories. Categories are public-read.
     *   Only administrators can create, update, or delete categories.
     * @path /categories/{categoryId}
     * @allow (list) Any user listing all categories.
     * @deny (create) A non-admin user trying to create a category.
     * @principle Public read for structural content, with admin-only writes.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Manages article tags. Tags are public-read.
     *   Only administrators can create, update, or delete tags.
     * @path /tags/{tagId}
     * @allow (get) Any user reading a specific tag.
     * @deny (delete) A non-admin user trying to delete a tag.
     * @principle Public read for structural content, with admin-only writes.
     */
    match /tags/{tagId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Manages media assets. All media is public-read.
     *   Only administrators can upload, update, or delete media.
     * @path /media/{mediaId}
     * @allow (get) Any user viewing a media asset.
     * @deny (create) A non-admin user trying to upload a file.
     * @principle Public read for asset content, with admin-only writes.
     */
    match /media/{mediaId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Manages navigation menus. Menus are public-read.
     *   Only administrators can create, update, or delete menus.
     * @path /menus/{menuId}
     * @allow (list) The application frontend fetching all menus.
     * @deny (update) A regular user trying to change a menu link.
     * @principle Public read for structural content, with admin-only writes.
     */
    match /menus/{menuId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Manages global site configuration (theme, settings, etc.).
     *   Configuration is public-read. Only administrators can change settings.
     * @path /configuration/{configurationId}
     * @allow (get) The application frontend reading the site configuration.
     * @deny (create) A user trying to create a new configuration document.
     * @principle Public read for configuration data, with admin-only writes.
     */
    match /configuration/{configurationId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Defines administrator roles. The existence of a document
     *   grants admin privileges. This collection is locked down to prevent
     *   privilege escalation and must be managed from the Firebase Console.
     * @path /roles_admin/{uid}
     * @allow (get) An admin checking if another user is also an admin.
     * @deny (create) Any user (including an admin) trying to make someone else an admin.
     * @principle Prevents privilege escalation by making roles immutable via rules.
     */
    match /roles_admin/{uid} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}