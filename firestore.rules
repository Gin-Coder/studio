
/**
 * This ruleset enforces a security model for the Danny Store e-commerce application.
 *
 * Core Philosophy:
 * The security model is built on the principle of least privilege, segregating data
 * based on access patterns. It combines user-ownership for private data with a
 * public-read model for the product catalog. All sensitive write operations, such as
 * creating orders or moderating content, are intended to be performed by a trusted
 * server backend, and are therefore disallowed for clients.
 *
 * Data Structure:
 * - User-specific, private data (like orders, carts, and try-on requests) is
 *   nested under the `/users/{userId}` path or uses the user's UID as the document ID
 *   in a top-level collection (e.g., `/carts/{userId}`). This structure enables
 *   path-based ownership rules for clear and secure access control.
 * - Publicly-facing data, such as products, categories, and published reviews,
 *   is stored in top-level collections for easy and performant public querying.
 * - Administrative data, like roles, is stored in a locked-down collection,
 *   inaccessible to clients.
 *
 * Key Security Decisions:
 * - Default Deny: Access is denied unless explicitly granted.
 * - User Data Isolation: Users can only access their own data. User enumeration
 *   is explicitly disabled by disallowing `list` operations on the `users` collection.
 * - Server-Side Authority: All business logic and sensitive operations (e.g., order
 *   processing, review moderation, quota management) are assumed to be handled by a
 *   secure backend. Client-side write access is heavily restricted to prevent tampering.
 * - Conditional Public Access: Public data is often conditionally available. For example,
 *   only products marked as `isActive` are viewable via direct `get`, and only reviews
 *   marked as `published` are readable.
 * - Immutable Ownership: The `userId` field on documents like reviews and orders is
 *   denormalized for authorization and is made immutable after creation to maintain
 *   data integrity.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    //-------------------------------------------------------------------------
    // Helper Functions
    //-------------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing data ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the user is the owner and the document already exists.
     * Used for safe update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates that a user cannot grant themselves administrative privileges
     * when creating their user document.
     */
    function isCreatingOwnUser(userId) {
      let data = request.resource.data;
      return isOwner(userId)
        && !("isAdmin" in data)
        && !("roles" in data);
    }

    /**
     * Validates that a user can update their own profile fields without
     * escalating privileges or changing immutable data.
     */
     function canUpdateOwnProfile() {
        let incomingData = request.resource.data;
        let existingData = resource.data;

        // Fields that are not allowed to be changed by the user at all.
        let areProtectedFieldsUntouched = 
            !("isAdmin" in incomingData) && 
            !("roles" in incomingData) &&
            !("createdAt" in incomingData) &&
            !("email" in incomingData) &&
            !("displayName" in incomingData);
        
        // Fields that can be changed, so we validate their types.
        let areUpdatableFieldsValid = 
            (!("language" in incomingData) || incomingData.language is string) &&
            (!("phoneWhatsApp" in incomingData) || incomingData.phoneWhatsApp is string) &&
            (!("consentWhatsApp" in incomingData) || incomingData.consentWhatsApp is bool) &&
            (!("lastLoginAt" in incomingData) || incomingData.lastLoginAt == request.time);

        return areProtectedFieldsUntouched && areUpdatableFieldsValid;
     }


    //-------------------------------------------------------------------------
    // User Data Collections
    //-------------------------------------------------------------------------

    /**
     * @description Users can create and manage their own profile document.
     *              They are prevented from changing their own roles or admin status.
     * @path        /users/{userId}
     * @allow       (create) A new user creating their own document.
     * @deny        (list) A user trying to list all other users.
     * @deny        (update) A user trying to set `isAdmin` to true on their profile.
     * @principle   Enforces document ownership and prevents privilege escalation.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isCreatingOwnUser(userId);
      allow update: if isExistingOwner(userId) && canUpdateOwnProfile();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description A user's cart is private to them. The document ID is the user's UID.
     * @path        /carts/{userId}
     * @allow       (get) A user reading their own cart document.
     * @deny        (list) A user trying to list all carts in the system.
     * @deny        (get) A user trying to read another user's cart.
     * @principle   Restricts access to a user's own data tree using path-based ownership.
     */
    match /carts/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Users can read their own orders. All writes must go through the server.
     * @path        /users/{userId}/orders/{orderId}
     * @allow       (list) A user listing their own past orders.
     * @deny        (create) A user trying to create an order directly from the client.
     * @deny        (get) A user trying to access another user's order history.
     * @principle   Restricts access to a user's own data tree; writes are server-only.
     */
    match /users/{userId}/orders/{orderId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Users can read their own try-on requests. All writes must go through the server.
     * @path        /users/{userId}/tryonRequests/{requestId}
     * @allow       (get, list) A user viewing their virtual try-on requests and history.
     * @deny        (create) A user trying to create a try-on request directly.
     * @deny        (get) A user trying to view another user's try-on requests.
     * @principle   Restricts access to a user's own data tree; writes are server-only.
     */
    match /users/{userId}/tryonRequests/{requestId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Users can read their own try-on usage quotas. Writes are server-only.
     * @path        /users/{userId}/tryonUsage/days/{YYYYMMDD}
     * @allow       (get) A user checking their remaining try-on quota for the day.
     * @deny        (update) A user trying to reset their own usage count.
     * @deny        (get) A user trying to check another user's quota.
     * @principle   Restricts access to a user's own data tree; writes are server-only.
     */
    match /users/{userId}/tryonUsage/days/{YYYYMMDD} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    //-------------------------------------------------------------------------
    // Public & Semi-Public Collections
    //-------------------------------------------------------------------------

    /**
     * @description Products that are active are publicly readable. All writes are server-only.
     * @path        /products/{productId}
     * @allow       (get) Anyone reading an active product's details. auth: any.
     * @deny        (get) Anyone trying to read a product where `isActive` is false.
     * @deny        (create) Any client trying to add a new product.
     * @principle   Allows public read for catalog data while restricting writes to admins (via server).
     */
    match /products/{productId} {
      allow get: if resource.data.isActive == true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Product categories are publicly readable. All writes are server-only.
     * @path        /categories/{categoryId}
     * @allow       (list) Anyone listing all available product categories. auth: any.
     * @deny        (create) Any client trying to add a new category.
     * @principle   Allows public read for catalog data while restricting writes to admins (via server).
     */
    match /categories/{categoryId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Product collections are publicly readable. All writes are server-only.
     * @path        /collections/{collectionId}
     * @allow       (list) Anyone listing all available product collections. auth: any.
     * @deny        (create) Any client trying to add a new collection.
     * @principle   Allows public read for catalog data while restricting writes to admins (via server).
     */
    match /collections/{collectionId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description CMS pages (e.g., about, FAQ) are publicly readable. All writes are server-only.
     * @path        /pages/{pageId}
     * @allow       (get) Anyone reading a CMS page. auth: any.
     * @deny        (update) Any client trying to modify page content.
     * @principle   Allows public read for content data while restricting writes to admins (via server).
     */
    match /pages/{pageId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Reviews can be created by authenticated users. Published reviews are public.
     * @path        /reviews/{reviewId}
     * @allow       (create) A signed-in user submitting a review for a product.
     * @allow       (get) Anyone reading a review where `status` is 'published'.
     * @deny        (get) Anyone trying to read a review with status 'pending' or 'hidden'.
     * @deny        (update) A user trying to change another user's review.
     * @principle   Enforces document ownership for writes and conditional public access for reads.
     */
    match /reviews/{reviewId} {
      // NOTE: `list` is public, but clients MUST query `where('status', '==', 'published')`.
      // The `get` rule below secures individual non-published documents from direct access.
      allow get: if resource.data.status == 'published';
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

    //-------------------------------------------------------------------------
    // Server-Only & Private Collections
    //-------------------------------------------------------------------------

    /**
     * @description Roles define admin permissions and are not client-accessible.
     * @path        /roles/{roleId}
     * @allow       (none) No client operation is permitted.
     * @deny        (get) Any client trying to read role definitions.
     * @principle   Secures administrative data by denying all client access.
     */
    match /roles/{roleId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Global site settings are publicly readable but not listable or writable by clients.
     * @path        /siteSettings/global
     * @allow       (get) Any client reading the global site configuration.
     * @deny        (list, create, update, delete) Any client attempting any other operation.
     * @principle   Allows public read for configuration while restricting writes to admins (via server).
     */
    match /siteSettings/global {
      allow get: if true;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Order events contain sensitive history and are not client-accessible.
     * @path        /orderEvents/{orderId}/events/{eventId}
     * @allow       (none) No client operation is permitted.
     * @deny        (get) Any client trying to read order history events.
     * @principle   Secures sensitive data by denying all client access. The data structure
     *              lacks a direct userId, making secure client rules impossible.
     */
    match /orderEvents/{orderId}/events/{eventId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Survey prompts are user-specific. Writes are handled by the server.
     * @path        /surveyPrompts/{orderId}
     * @allow       (get) A user reading their own survey prompt. auth: owner.
     * @deny        (list) A user trying to list all survey prompts in the system.
     * @deny        (update) A user trying to snooze or submit a survey directly.
     * @principle   Restricts access based on denormalized ownership data (`userId` field).
     */
    match /surveyPrompts/{orderId} {
      allow get: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}

    