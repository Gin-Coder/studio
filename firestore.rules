rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * Typically used for path-based ownership rules (e.g., /users/{userId}).
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the user is the owner of an existing document.
     * Crucial for secure update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }



    /**
     * Validates that the `userId` field in a new document matches the creator's UID.
     * Enforces correct ownership data on creation.
     */
    function isCreatingOwnData() {
      return isSignedIn() && request.resource.data.userId == request.auth.uid;
    }

    /**
     * Validates that the `userId` field in a document is immutable on update.
     * Prevents re-assigning ownership of a document.
     */
    function isUserIdUnchanged() {
      return request.resource.data.userId == resource.data.userId;
    }

    /**
     * Checks if the user is the owner of a document referenced by a get() call.
     */
    function isOwnerOf(doc) {
      return isSignedIn() && request.auth.uid == doc.data.userId;
    }

    // -------------------------------------------------------------------------
    // User Data
    // -------------------------------------------------------------------------

    /**
     * @description Users can create, read, and update their own document, but cannot delete it or make themselves an admin.
     * @path /users/{userId}
     * @allow (create) A new user signing up: create /users/user_abc with auth.uid=user_abc.
     * @allow (update) A user updating their own display name: update /users/user_abc with auth.uid=user_abc.
     * @deny (get) A user trying to read another user's profile: get /users/user_xyz with auth.uid=user_abc.
     * @deny (list) A user trying to list all users: list /users.
     * @deny (update) A user trying to give themselves admin rights: update /users/user_abc with { isAdmin: true }.
     * @principle Restricts access to a user's own data tree and prevents privilege escalation.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Prevent user enumeration for privacy.
      allow create: if isOwner(userId);
      allow update: if isOwner(userId) &&
        (!('isAdmin' in request.resource.data) && !('roles' in request.resource.data)); // Prevent self-promotion.
      allow delete: if false; // Deletions should be handled by a backend process.
    }

    /**
     * @description Stores a user's shopping cart. Only the user can access their own cart.
     * @path /carts/{userId}
     * @allow (get) A user fetching their own cart: get /carts/user_abc with auth.uid=user_abc.
     * @allow (create) A user adding the first item to their cart: create /carts/user_abc with auth.uid=user_abc.
     * @deny (get) A user trying to view another user's cart: get /carts/user_xyz with auth.uid=user_abc.
     * @principle Enforces strict data ownership using path-based security.
     */
    match /carts/{userId} {
      allow get, list: if isOwner(userId);
      allow create, update: if isOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    // -------------------------------------------------------------------------
    // Admin & Site Configuration (Backend Only)
    // -------------------------------------------------------------------------

    /**
     * @description Stores role definitions. Completely locked down from client access.
     * @path /roles/{roleId}
     * @allow (none) All client operations are denied.
     * @deny (get) Any user attempting to read role definitions: get /roles/admin.
     * @principle Secures sensitive configuration data by making it accessible only via the Admin SDK on the server.
     */
    match /roles/{roleId} {
      allow get, list: if false;
      allow create, update, delete: if false;
    }

    /**
     * @description Stores global site settings. Completely locked down from client access.
     * @path /siteSettings/global
     * @allow (none) All client operations are denied.
     * @deny (get) Any user attempting to read site settings: get /siteSettings/global.
     * @principle Secures sensitive configuration data by making it accessible only via the Admin SDK on the server.
     */
    match /siteSettings/global {
      allow get, list: if false;
      allow create, update, delete: if false;
    }

    // -------------------------------------------------------------------------
    // Public Catalog Data (Read-Only for Clients)
    // -------------------------------------------------------------------------

    /**
     * @description Publicly readable product data. Only active products are visible. Writes are blocked from the client.
     * @path /products/{productId}
     * @allow (get) Any user reading an active product: get /products/prod_123 where the document has isActive: true.
     * @deny (get) Any user trying to read an inactive product: get /products/prod_456 where isActive: false.
     * @deny (create) Any user trying to add a new product.
     * @principle Provides public read access to catalog data while protecting it from unauthorized modification.
     */
    match /products/{productId} {
      allow get: if resource.data.isActive == true;
      allow list: if true; // Client queries MUST filter for `isActive == true`.
      allow create, update, delete: if false; // Managed by backend.
    }

    /**
     * @description Publicly readable category data. Writes are blocked from the client.
     * @path /categories/{categoryId}
     * @allow (get, list) Any user reading categories.
     * @deny (create) Any user trying to add a new category.
     * @principle Provides public read access to catalog data while protecting it from unauthorized modification.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create, update, delete: if false; // Managed by backend.
    }

    /**
     * @description Publicly readable product collections. Writes are blocked from the client.
     * @path /collections/{collectionId}
     * @allow (get, list) Any user reading collections.
     * @deny (create) Any user trying to add a new collection.
     * @principle Provides public read access to catalog data while protecting it from unauthorized modification.
     */
    match /collections/{collectionId} {
      allow get, list: if true;
      allow create, update, delete: if false; // Managed by backend.
    }

    /**
     * @description Publicly readable CMS pages. Writes are blocked from the client.
     * @path /pages/{pageId}
     * @allow (get, list) Any user reading a CMS page.
     * @deny (create) Any user trying to create a new page.
     * @principle Provides public read access to content while protecting it from unauthorized modification.
     */
    match /pages/{pageId} {
      allow get, list: if true;
      allow create, update, delete: if false; // Managed by backend.
    }

    // -------------------------------------------------------------------------
    // User Content & Business Logic
    // -------------------------------------------------------------------------

    /**
     * @description User orders. Users can only read their own orders. All writes are server-only.
     * @path /orders/{orderId}
     * @allow (get) A user reading their own order: get /orders/ord_123 where doc userId is user_abc and auth.uid is user_abc.
     * @deny (get) A user trying to read another user's order: get /orders/ord_456.
     * @deny (create) A user trying to create an order directly from the client.
     * @principle Enforces ownership for reads and delegates all write operations to a trusted server environment.
     */
    match /orders/{orderId} {
      allow get: if isOwner(resource.data.userId);
      allow list: if isSignedIn(); // Client queries MUST filter by `userId`.
      allow create, update, delete: if false; // All order modifications are server-side.
    }

    /**
     * @description Order history events. Users can read events for their own orders. Writes are server-only.
     * @path /orderEvents/{orderId}/events/{eventId}
     * @allow (get) A user reading events for their own order: get /orderEvents/ord_123/events/evt_abc.
     * @deny (get) A user trying to read events for someone else's order: get /orderEvents/ord_456/events/evt_xyz.
     * @principle Secures a subcollection by checking ownership on the parent document.
     */
    match /orderEvents/{orderId}/events/{eventId} {
      allow get, list: if isOwnerOf(get(/databases/$(database)/documents/orders/$(orderId)));
      allow create, update, delete: if false; // Server-side only.
    }

    /**
     * @description Product reviews. Anyone can read published reviews. Users can create reviews and manage their own non-published reviews.
     * @path /reviews/{reviewId}
     * @allow (get) Any user reading a published review: get /reviews/rev_123 where status is 'published'.
     * @allow (get) A user reading their own pending review: get /reviews/rev_456 where userId matches and status is 'pending'.
     * @allow (create) A user submitting a review for a product.
     * @deny (update) A user trying to change the status of their review from 'pending' to 'published'.
     * @principle Implements a mixed-access model: public reads for published content, and ownership for writes and private content.
     */
    match /reviews/{reviewId} {
      allow get: if resource.data.status == 'published' || isOwner(resource.data.userId);
      allow list: if true; // Client queries MUST filter by `status == 'published'` for public listings.
      allow create: if isCreatingOwnData();
      allow update: if isExistingOwner(resource.data.userId) && request.resource.data.status == resource.data.status; // Owner can edit, but not change status.
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Post-purchase survey prompts. Users can read and update their own prompt (e.g., to snooze or submit).
     * @path /surveyPrompts/{orderId}
     * @allow (get) A user reading their own survey prompt: get /surveyPrompts/ord_123.
     * @deny (create) A user trying to create a survey prompt. This is a server-side action.
     * @principle Enforces ownership for reads and updates, while delegating creation to the server.
     */
    match /surveyPrompts/{orderId} {
      allow get: if isOwner(resource.data.userId);
      allow list: if isSignedIn(); // Client queries MUST filter by `userId`.
      allow create: if false; // Created by server when order is delivered.
      allow update: if isExistingOwner(resource.data.userId) && isUserIdUnchanged();
      allow delete: if false;
    }

    // -------------------------------------------------------------------------
    // Virtual Try-On Feature
    // -------------------------------------------------------------------------

    /**
     * @description User's daily quota for the virtual try-on feature. Users can only read their own quota.
     * @path /tryonUsage/{userId}/days/{YYYYMMDD}
     * @allow (get) A user checking their own try-on usage: get /tryonUsage/user_abc/days/20230101.
     * @deny (update) A user trying to reset their own usage count.
     * @principle Enforces ownership for reads and delegates quota management to a trusted server environment.
     */
    match /tryonUsage/{userId}/days/{YYYYMMDD} {
      allow get, list: if isOwner(userId);
      allow create, update, delete: if false; // Quota is managed by the server.
    }

    /**
     * @description Virtual try-on requests. Users can read their own requests. All writes are server-only.
     * @path /tryonRequests/{requestId}
     * @allow (get) A user checking the status of their request: get /tryonRequests/req_123.
     * @deny (create) A user trying to create a request directly. This must go through the API for quota checks.
     * @principle Enforces ownership for reads and delegates all write operations to a trusted server environment.
     */
    match /tryonRequests/{requestId} {
      allow get: if isOwner(resource.data.userId);
      allow list: if isSignedIn(); // Client queries MUST filter by `userId`.
      allow create, update, delete: if false; // All requests are managed by the server.
    }
  }
}